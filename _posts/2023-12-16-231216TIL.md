---
layout: single
title: 타입스크립트, 집합으로 이해하기
category: TIL
toc: true
toc_sticky: true
---

# TIL 23. 12. 16

## 타입스크립트, 집합으로 이해하기

타입스크립트의 **'타입'은 사실 여러 개의 값을 포함하는 '집합'**이다. 여러 개의 숫자 값들(1, -20, Infinity, NaN 등)을 묶어 놓은 집합은 Nnumber 타입이 된다.

> 집합: 동일한 속성을 갖는 여러 개의 요소들을 하나의 그룹으로 묶은 단위

하나의 값만 포함하는 타입인 Number Literal 타입은 Number 타입에 속하는 부분 집합으로 볼 수 있다. 

> [집합으로 타입 이해하기](https://ahnheejong.name/articles/types-intro/#%EC%A7%91%ED%95%A9%EC%9C%BC%EB%A1%9C-%ED%83%80%EC%9E%85-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)

타입스크립트의 모든 타입들은 집합으로써 서로 포함하고 포함되는 관계를 갖는다. 이런 관계에서 **다른 타입을 포함하는 타입을 슈퍼 타입(부모 타입)**, **반대는 서브 타입(자식 타입)**이라고 한다.

![notion image](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F96054ff9-aac2-4d59-9b98-324328b88028%2FUntitled.png?table=block&id=348d5a9f-4b79-4cfd-8eb0-dc04b4783e51&cache=v2)

## 타입 호환성

타입 호환성이란 **A와 B 두 개의 타입이 존재할 때 A 타입의 값을 B 타입으로 취급해도 괜찮은지 판단**하는 것을 의미한다. 만약 A 타입의 값이 B 타입의 값으로 취급되어도 괜찮다면 호환된다고 한다.

예를 들어 Number Literal 타입의 값인 10은 Number 타입의 값으로 취급하는 것이 가능하다. 그러나 반대로는 불가능하다. Number 타입이 더 큰 타입이기 때문에.

```ts
let num1: number = 10;
let num2: 10 = 10;

num1 = num2; // ✅ OK
num2 = num1; // ❌ Error: Type 'number' is not assignable to type '10'
```

타입스크립트에서는 슈퍼 타입의 값을 서브 타입의 값으로 취급하는 것을 허용하지 않는다. **서브 타입의 값을 슈퍼 타입의 값으로 취급하는 것을 업 캐스팅**이라 부르고, **반대는 다운 캐스팅**이라고 부른다. 

![notion image](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F42382978-4468-424e-a3ea-95b6747653ca%2FUntitled.png?table=block&id=53270154-fdd5-45fd-ad96-579ec8f10c0a&cache=v2)

> 추가 읽을거리 [TypeScript 타입 시스템 뜯어보기: 타입 호환성](https://toss.tech/article/typescript-type-compatibility)

## 타입 계층도와 함께 기본타입 살펴보기

![notion image](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F593968f2-7c02-45ab-b152-66202eb4a8c2%2FUntitled.png?table=block&id=fcf12561-2c5d-46f0-9fca-db34ecddbcca&cache=v2)

### unknown 타입 (전체 집합)

unknown 타입은 타입 계층도의 최상단에 위치한다. 따라서 unknown 타입 변수에는 모든 타입의 값을 할당할 수 있다. unknown 타입은 모든 타입을 부분 집합으로 갖는 타입스크립트 전체 집합이다. 즉, 모든 타입은 unknown 타입으로 업 캐스트 할 수 있다. 

하지만 반대는 불가능하다. unknown 타입의 값은 any를 제외한 어떤 타입의 변수에도 할당할 수 없다. 다운 캐스팅이 불가능하다.

```ts
let a: unknown = 1;   
let b: unknown = "hello";   
let c: unknown = true;   
let d: unknown = null;        
let e: unknown = undefined;
let f: unknown = [];           
let g: unknown = {}; 
let h: unknown = () => {};  
let i: unknown;

let j: number = i; // ❌ Error: Type 'unknown' is not assignable to type 'number'.
```

### never 타입 (공집합 타입)

never 타입은 타입 계층도에서 가장 아래에 위치한다. 집합의 관점에서 보면 never는 **공집합을 뜻하는 타입**이다. 

> 공집합: 아무것도 포함하지 않는 집합

never 타입에 해당하는 값은 아무것도 없었다. 무한루프와 같이 무언가를 반환할 수 없었기 때문이다. 

공집합은 모든 집합의 부분 집합이다. 그러므로 never 타입은 모든 타입의 서브 타입이다. never 타입은 모든 타입으로 업 캐스팅 할 수 있다. 반대는 불가능하다.

```ts 
function neverFunc() {
  function neverFunc(): never {
    while (true) {}
  }
  let a: number = neverFunc();
  let b: string = neverFunc();
  let c: never = 10; // ❌ Error: Type 'number' is not assignable to type 'never'
}
```

### void 타입

void 타입은 아무것도 반환하지 않는 함수의 반환 값 타입으로 주로 사용된다. void 타입은 undefined 타입의 슈퍼 타입이다. 반환 값이 void인 함수에서 undefined을 반환 해도 오류가 발생하지 않는 이유이다. undefined 타입은 void 타입의 서브 타입이므로 업 캐스팅이 가능하기 때문에.

void 타입의 서브 타입으로 undefined와 never 타입이 있다. void 타입의 서브 타입 외에는 다른 타입의 값을 할당할 수 없다.

```ts 
let voidVar: void;
voidVar = undefined;

let neverVar: never;
voidVar = neverVar;
```

### any 타입

any 타입은 타입 계층도를 완전히 무시한다. 모든 타입의 슈퍼 타입이 될 수도 있고 모든 타입의 서브 타입이 될 수도 있다.

단, never 타입의 변수에는 any 타입의 값을 할당할 수는 없다. never 타입은 공집합이므로 어떤 타입도 다운 캐스팅 할 수 없다.

```ts
let anyValue: any;

let num: number = anyValue;   // any -> number 
let str: string = anyValue;   // any -> string 
let bool: boolean = anyValue; // any -> boolean

let neverVar: never = anyValue; // ❌ Error: Type 'any' is not assignable to type 'never'
```

any 타입은 알지 못하는 타입을 표현해야 하는 경우(서드 파티 라이브러리 등)에만 사용하도록 권장한다. any 타입을 남발하면 타입스크립트를 쓰는 의미가 없다. 

## 객체 타입의 호환성

모든 객체 타입 역시 각각 다른 객체 타입들과 슈퍼-서브 타입 관계를 갖는다. 업 캐스팅은 허용하고 다운 캐스팅은 불가.

