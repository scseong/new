---
layout: single

title: TIL 23-10-17

category: TIL
---

# 데이터 타입(심화)

## 오늘 공부한 내용

- 데이터 타입(심화)

## 데이터 타입(심화)

### 데이터 타입의 종류

자바스크립트에서 값의 타입은 크게 기본형(Primitive Type)과 참조형(Reference Type)으로 구분된다. **값의 저장 방식**과 **불변성 여부**로 구분한다.

```markdown
1. 복제 방식
    a. 기본형: 값이 담긴 주소값을 바로 복제
    b. 참조형: 값이 담긴 주소값들로 이루어진 묶음을 가리키는 주소값을 복제
2. 불변성 여부
    a. 기본형: 불변성을 띔
    b. 참조형: 불변성을 띄지 않음
```

불변성을 이해하기 위해 메모리와 데이터에 대한 내용을 먼저 이해해야 한다. 아래에서 살펴보자.

### 메모리와 데이터에 관한 배경지식

**비트**는 컴퓨터가 이해할 수 있는 가장 작은 단위로 0과 1만으로 정보를 표현한다. 비트의 수가 많을수록 표현할 수 있는 정보가 다양해진다. 비트들이 모여서 '메모리'가 만들어진다.

그런데 수많은 비트를 일일이 찾는다는 것은 부담이 된다. 비트를 가지고 정보를 표현하기 적합한 개수로 묶은 단위가 **바이트**이다. 1바이트(byte)는 8비트로 구성된다.

모든 데이터는 바이트 단위의 식별자인 메모리 주소값을 통해서 구분이 된다. 바이트 단위로 데이터를 구분할 수 있다.

64비트 정수를 메모리에 저장한다고 하자. 메모리 주소는 바이트 단위라고 했다. 64비트는 8바이트이므로 64비트 정수는 8개의 연속된 바이트에 저장된다.

### 변수 선언과 데이터 할당

이제 변수를 어떻게 메모리에 할당하는지 살펴보자.

```js
var str = 'test!';
```

식별자인 str과 값이 'test!'를 메모리에 저장해야 한다. 식별자와 원시 값은 메모리의 스택 영역에 저장된다. 메모리 영역을 식별자를 저장하는 변수 영역과 값을 저장하는 데이터 영역으로 나누어져 있다고 하자.

> 스택 메모리: 프로그램 실행 중에 사용되는 변수와 데이터를 관리하는 데 사용

| 주소(변수 영역) | …   | 1002        | 1003 | 1004 | 1005 | ... |
| --------- | --- | ----------- | ---- | ---- | ---- | --- |
| 데이터       |     | str / @5002 |      |      |      |     |

| 주소 (데이터 영역) | …   | 5002    | 5003 | 5004 | 5005 | …   |
| ----------- | --- | ------- | ---- | ---- | ---- | --- |
| 데이터         |     | 'test!' | -    |      |      |     |

변수 영역의 데이터에는 식별자와 값을 참조하는 주소가 저장된다. 현재 사용할 수 있는 메모리 주소에서 가장 가까운 주소에 할당한다고 하자. 식별자인 변수명 str은 1002번지에 저장이 된다. 하지만 아직 값이 저장된 주소는 참조할 수 없다. 

값인 'test!'는 데이터 영역의 5002번지 메모리에 저장되었다고 하자. 이제 식별자가 저장된 1002번지에서 값이 저장된 5002번지를 참조한다.

"변수 영역과 데이터 영역을 나눌 것 없이 변수 영역의 데이터에 값을 바로 저장하면 되지 않나?" 라고 생각할 수 있다.

#### 값을 바로 변수에 대입하지 않는 이유

그 이유는 먼저 **자유로운 데이터 변환**을 위해서이다.

"이미 입력한 문자열이 길어진다면?" ➡ 문자열 타입의 값을 변경하고자 한다. `teeeeest!'로. 문자열은 글자수에 따라 크기가 달라진다. 어떤 값이 들어올지 모르기 때문에 미리 메모리 공간을 확보둘 수 없다. 

알파벳 한글자를 표현하기 위해 1바이트를 사용한다. 이미 할당된 문자열보다 큰 문자열을 저장해야 하는데 값을 바로 저장하게 된다면 1002번지 이후부터 저장되어 있는 모든 데이터를 밀어놓고 값을 저장해야 할 것이다. 이는 비효율적인 방법이다.

두 번째 이유는 **메모리의 효율적 관리**하기 위해. 1만개의 변수를 생성해 각각 1을 할당해야한다고 하자. 

숫자형은 8바이트의 공간이 필요하다. 값을 바로 변수에 저장한다면 변수 영역에 1만개의 변수를 생성한다. 각각 2바이트로 할당한다고 하자. 1만개 * 8byte = 8만 byte가 필요하다.

| 주소  | …   | 1002  | 1003  | 1004  | 1005 | ... |
| --- | --- | ----- | ----- | ----- | ---- | --- |
| 데이터 |     | a / 1 | b / 1 | c / 1 | d /1 | ... |

변수 영역과 데이터 영역에 별도로 저장한다면 1이라는 값만 따로 저장하면 된다.

- 변수 영역: 1만개 * 2byte = 2만 byte

- 데이터 영역: 8byte

2만 8byte 만을 사용해 훨씬 효율적으로 똑같은 데이터를 저장할 수 있다.

| 주소(변수 영역) | …   | 1002      | 1003      | 1004      | 1005      | ... |
| --------- | --- | --------- | --------- | --------- | --------- | --- |
| 데이터       |     | a / @5002 | b / @5002 | c / @5002 | d / @5002 | ... |

| 주소 (데이터 영역) | …   | 5002 | 5003 | 5004 | 5005 | …   |
| ----------- | --- | ---- | ---- | ---- | ---- | --- |
| 데이터         |     | 1    | -    | -    |      |     |

 이러한 이유로 값을 바로 변수에 대입하지 않고 값을 참조하는 방식을 사용한다.

### 기본형 데이터와 참조형 데이터

이제 메모리를 기준으로 두 가지 주요 개념에 대해 살펴보자.

- 변수 vs 상수
  
  - 변수: <u>변수 영역</u> 메모리 <u>변경 가능</u>
  
  - 상수: <u>변수 영역</u> 메모리 <u>변경 불가능</u>

- 불변하다 vs 불변하지 않다
  
  - 불변하다: <u>데이터 영역</u> 메모리 <u>변경 불가능</u>
  
  - 불변하지 않다: <u>데이터 영역</u> 메모리 <u>변경 가능</u>

변수 영역에서 식별자와 값을 가리키는 주소를 변경 가능하면 변수이다. 값을 재할당했을 때 데이터 영역의 다른 주소에 값을 할당하고 해당 주소로 변수 영역에서 참조한다. 이전 값이 더이상 사용되지 않는다면 가비지컬렉터의 수거 대상이 된다.

## 부족한 내용 / 궁금한 내용

## 느낀점

변수 선언과 할당, 재할당을 메모리 관점에서 어떻게 동작하는지 강의를 들으며 이해할 수 있었다